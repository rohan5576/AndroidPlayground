# 🏹 8-Week Frontend-Focused DSA Mastery Plan

This is a curated **8-week daily plan** for mastering DSA problems relevant to **frontend interviews** — with **Easy / Medium / Hard tags** and **topic-wise grouping**.

## 📅 Schedule Overview
- **5 days/week** (Mon–Fri)
- **1.5–2 hrs/day**
- **Easy → Medium → Hard** progression each day
- Covers: Arrays, Strings, Linked List, Trees, Graphs, Recursion, DP, and JS-specific coding challenges.

---

# 🚀 Basic Coding Warm-up 
Mastering these ensures you won’t get stuck on simple logic questions.

---

## 📜 String Problems
- Reverse a string (without built-in `reverse`)
- Check if a string is a palindrome
- Find the first non-repeating character
- Count occurrences of each character
- Remove duplicate characters
- Check if two strings are anagrams
- Find the longest word in a sentence
- Capitalize the first letter of each word

---

## 📦 Array Problems
- Find the maximum and minimum element
- Remove duplicates from an array
- Find the intersection of two arrays
- Rotate an array by `k` positions
- Find the missing number in a sequence
- Move all zeroes to the end
- Find the second largest element
- Merge two sorted arrays

---

## 🔢 Number Problems
- Check if a number is prime
- Generate Fibonacci sequence up to `n`
- Find the factorial of a number
- Reverse the digits of a number
- Check if a number is an Armstrong number
- Find GCD and LCM of two numbers
- Check if a number is a perfect square
- Find the sum of digits of a number

---

## 🎨 Pattern Problems
- FizzBuzz
- Print a pyramid pattern of stars
- Print Pascal’s triangle
- Print the multiplication table for a given number

---

## 🔍 Searching & Sorting
- Implement Linear Search
- Implement Binary Search
- Bubble Sort
- Insertion Sort
- Selection Sort

---

## 🔄 Recursion Basics
- Reverse a string using recursion
- Calculate factorial using recursion
- Generate Fibonacci using recursion
- Find sum of array elements using recursion

---

## Week 1 – Arrays (Iteration, Two Pointers, Hashing)

**Day 1**
- (E) Two Sum – HashMap lookup  
- (E) Find Missing Number – Math sum / XOR  
- (E) Max/Min in Array – Iterative scan  

**Day 2**
- (E) Merge Two Sorted Arrays – Two Pointers  
- (E) Move Zeroes to End – In-place swap  

**Day 3**
- (E) Remove Duplicates from Sorted Array – Two Pointers  
- (M) Majority Element – Boyer–Moore Voting  

**Day 4**
- (E) Best Time to Buy and Sell Stock – Greedy  
- (E) Plus One – Array digit manipulation  

**Day 5**
- (M) Product of Array Except Self – Prefix/Suffix  
- (M) Subarray Sum Equals K – Prefix Sum + HashMap  

---

## Week 2 – Strings (Sliding Window, Hashing, Expansion)

**Day 6**
- (E) Valid Anagram – Sorting / HashMap  
- (E) Palindrome Checker – Two Pointers  

**Day 7**
- (E) Merge Strings Alternately – String building  
- (E) FizzBuzz – Loop basics  

**Day 8**
- (M) Longest Substring Without Repeating – Sliding Window  
- (M) Find All Anagrams in String – Sliding Window + HashMap  

**Day 9**
- (M) Group Anagrams – HashMap of arrays  
- (M) Decode String – Stack  

**Day 10**
- (M) Longest Palindromic Substring – Expand from center  
- (M) Word Break – DP  

---

## Week 3 – Linked List & Stacks/Queues

**Day 11**
- (E) Reverse Linked List – Iterative/Recursive  
- (E) Merge Two Sorted Lists – Two Pointers  

**Day 12**
- (M) Remove Nth Node From End – Two Pointers  
- (M) Detect Linked List Cycle – Floyd’s Algorithm  

**Day 13**
- (E) Valid Parentheses – Stack  
- (E) Min Stack – O(1) min tracking  

**Day 14**
- (M) Implement Queue using Stacks – Two Stacks  
- (M) Sliding Window Maximum – Deque  

**Day 15**
- (H) LRU Cache – Map + Doubly Linked List  

---

## Week 4 – Trees (DFS, BFS)

**Day 16**
- (E) Maximum Depth of Binary Tree – DFS  
- (E) Symmetric Tree – BFS/DFS  

**Day 17**
- (M) Binary Tree Level Order Traversal – BFS  
- (M) 01 Matrix – BFS  

**Day 18**
- (M) Number of Islands – DFS/BFS  
- (M) Rotting Oranges – BFS  

**Day 19**
- (H) Serialize/Deserialize Binary Tree – BFS/DFS  
- (M) Lowest Common Ancestor – DFS  

**Day 20**
- (H) Build Virtual DOM diff logic – Tree diffing  

---

## Week 5 – Graphs (Traversal, Union-Find, Shortest Path)

**Day 21**
- (M) Clone Graph – DFS/BFS  
- (M) Course Schedule – Topological Sort  

**Day 22**
- (H) Word Ladder – BFS  
- (H) Alien Dictionary – Topological Sort  

**Day 23**
- (H) Redundant Connection – Union-Find  
- (M) Count Connected Components – DFS  

**Day 24**
- (M) Shortest Path in Binary Matrix – BFS  
- (H) Minimum Window Substring – Sliding Window  

**Day 25**
- (H) Scheduler with Priorities – Heap  

---

## Week 6 – Recursion & Backtracking

**Day 26**
- (E) Factorial – Recursion basics  
- (E) Fibonacci – Recursive + Memoization  

**Day 27**
- (M) Subsets / Power Set – Backtracking  
- (M) Palindrome Partitioning – Backtracking  

**Day 28**
- (M) Flatten Nested Arrays – Recursion  
- (M) Flatten Deeply Nested Object – Recursion  

**Day 29**
- (H) N-Queens – Backtracking  

**Day 30**
- (M) Build Recursive JSON Diff Tool – Recursion  

---

## Week 7 – Dynamic Programming

**Day 31**
- (E) Climbing Stairs – Memoization, Tabulation  
- (M) House Robber – DP  

**Day 32**
- (M) Coin Change – DP  
- (M) Longest Increasing Subsequence – DP  

**Day 33**
- (H) Edit Distance – 2D DP  
- (M) Partition Equal Subset Sum – Knapsack DP  

**Day 34**
- (M) Max Subarray – Kadane’s Algorithm  
- (M) Max Product Subarray – DP  

**Day 35**
- (M) Binary Search on Answer (Koko Bananas) – Binary Search + Greedy  

---

## Week 8 – JS-Specific Real-World Problems

**Day 36**
- (M) Debounce – Closures + setTimeout  
- (M) Throttle – Closures + Date  

**Day 37**
- (M) Custom bind / call / apply – Prototype + this binding  
- (M) Curry Function – Closures  

**Day 38**
- (M) Memoization – Caching  
- (M) Promise.all polyfill – Async control  

**Day 39**
- (M) Event Emitter – Pub/Sub  
- (M) Infinite Scroll Logic – DOM events + throttling  

**Day 40**
- (M) Retry with Delay Logic – Async retry  
- (M) setTimeout in the Event Loop – JS runtime model  

---

## 🎯 Tips for Success
- Warm up with Easy problems first each day.
- Track your progress in a spreadsheet or GitHub repo.
- After solving, always **write down the pattern/approach** in your own words.
- Revisit Medium/Hard problems after 1–2 weeks for retention.
